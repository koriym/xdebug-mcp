#!/usr/bin/env php
<?php

declare(strict_types=1);

// Load autoloader and get project root
$projectRoot = require __DIR__ . '/autoload.php';

// Parse command line arguments
function showHelp(string $scriptName): void {
    echo "Usage: $scriptName PHP_FILE [OPTIONS] [-- PHP_ARGS...]\n";
    echo "       $scriptName -- SCRIPT_FILE [SCRIPT_ARGS...]\n";
    echo "\n";
    echo "Runs Xdebug code coverage analysis on the specified PHP file or command.\n";
    echo "\n";
    echo "Arguments:\n";
    echo "  PHP_FILE      Path to PHP file to analyze (required)\n";
    echo "  PHP_ARGS      Arguments to pass to the PHP script (after --)\n";
    echo "  SCRIPT_FILE   PHP script to analyze (when using -- prefix)\n";
    echo "  SCRIPT_ARGS   Arguments for the script (when using -- prefix)\n";
    echo "\n";
    echo "Options:\n";
    echo "  --html        Generate HTML coverage report\n";
    echo "  --text        Generate text coverage summary (default)\n";
    echo "\n";
    echo "Examples:\n";
    echo "  # Standard usage:\n";
    echo "  $scriptName test/debug_test.php                    # Basic coverage analysis\n";
    echo "  $scriptName my_script.php --html                  # Generate HTML report\n";
    echo "  $scriptName bin/page.php --text -- get /          # Coverage with arguments\n";
    echo "\n";
    echo "  # Direct script execution:\n";
    echo "  $scriptName -- bin/page.php get /                 # Natural command style\n";
    echo "\n";
}

// Find -- separator to limit help flag checking
$separatorIndex = array_search('--', $argv, true);
$argsToCheck = $separatorIndex !== false 
    ? array_slice($argv, 0, $separatorIndex)  // Args before --
    : $argv;                                   // All args if no --

// Check for help flag or missing argument (only in pre-separator args)
if (in_array('--help', $argsToCheck) || in_array('-h', $argsToCheck) || count($argv) < 2) {
    showHelp($argv[0]);
    if (count($argv) < 2) {
        fwrite(STDERR, "❌ Error: PHP file argument is required\n");
        exit(1);
    }
    exit(0);
}

// Load common argument parser
$parse = require __DIR__ . '/parse.php';

// Parse base arguments - coverage has simplified pattern handling  
if ($argv[1] === '--') {
    // Pattern 2: -- script.php args (text format only)
    if (count($argv) < 3) {
        fwrite(STDERR, "❌ Error: Script file required after --\n");
        fwrite(STDERR, "Use '{$argv[0]} --help' for usage information\n");
        exit(1);
    }
    $phpBinary = PHP_BINARY;
    $targetFile = $argv[2];
    $phpArgs = array_slice($argv, 3);
    $outputFormat = 'text';
} else {
    // Pattern 1: script.php [--html|--text] [-- args]
    $phpBinary = PHP_BINARY;
    $targetFile = $argv[1];
    $outputFormat = 'text';
    $phpArgs = [];
    
    // Parse options and find -- separator
    for ($i = 2; $i < count($argv); $i++) {
        if ($argv[$i] === '--') {
            $phpArgs = array_slice($argv, $i + 1);
            break;
        } elseif ($argv[$i] === '--html') {
            $outputFormat = 'html';
        } elseif ($argv[$i] === '--text') {
            $outputFormat = 'text';
        }
    }
}

// Check target file exists
if (!file_exists($targetFile)) {
    fwrite(STDERR, "❌ Error: File '$targetFile' not found\n");
    fwrite(STDERR, "Use '{$argv[0]} --help' for usage information\n");
    exit(1);
}

// Generate unique coverage filename
$coverageTimestamp = date('Ymd_His') . '_' . getmypid();
$coverageDir = "/tmp/xdebug_coverage_$coverageTimestamp";

// Create coverage directory
mkdir($coverageDir, 0755, true);

// Build Xdebug options
$xdebugOpts = [
    '-dzend_extension=xdebug',
    '-dxdebug.mode=coverage',
    '-dxdebug.start_with_request=yes'
];

// Create a coverage wrapper script
$wrapperScript = "/tmp/coverage_wrapper_$coverageTimestamp.php";
$wrapperContent = "<?php
// Coverage analysis wrapper
xdebug_start_code_coverage(XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE);

// Capture arguments for the target script
\$targetArgs = " . var_export($phpArgs, true) . ";
if (!empty(\$targetArgs)) {
    \$newArgv = array_merge(['" . addslashes($targetFile) . "'], \$targetArgs);
    \$newArgc = count(\$newArgv);
    
    // Update all argument accessors
    \$_SERVER['argv'] = \$newArgv;
    \$_SERVER['argc'] = \$newArgc;
    \$GLOBALS['argv'] = \$newArgv;
    \$GLOBALS['argc'] = \$newArgc;
    \$argv = \$newArgv;
    \$argc = \$newArgc;
}

// Include and execute the target file
include '" . addslashes($targetFile) . "';

// Get coverage data
\$coverage = xdebug_get_code_coverage();
xdebug_stop_code_coverage();

// Generate report based on format
if ('" . $outputFormat . "' === 'html') {
    \$htmlDir = '" . addslashes($coverageDir) . "/html';
    mkdir(\$htmlDir, 0755, true);
    
    foreach (\$coverage as \$file => \$lines) {
        \$filename = basename(\$file);
        \$htmlFile = \$htmlDir . '/' . \$filename . '.html';
        
        \$html = '<html><head><title>Coverage: ' . htmlspecialchars(\$filename) . '</title></head><body>';
        \$html .= '<h1>Coverage Report: ' . htmlspecialchars(\$filename) . '</h1>';
        \$html .= '<table border=\"1\"><tr><th>Line</th><th>Code</th><th>Status</th></tr>';
        
        \$fileLines = file(\$file);
        foreach (\$fileLines as \$lineNum => \$line) {
            \$lineNum++; // 1-based line numbers
            \$status = 'not executable';
            if (isset(\$lines[\$lineNum])) {
                \$status = \$lines[\$lineNum] === 1 ? 'covered' : 'not covered';
            }
            \$color = \$status === 'covered' ? '#90EE90' : (\$status === 'not covered' ? '#FFB6C1' : '#D3D3D3');
            \$html .= '<tr style=\"background-color: ' . \$color . '\">';
            \$html .= '<td>' . \$lineNum . '</td>';
            \$html .= '<td><pre>' . htmlspecialchars(rtrim(\$line)) . '</pre></td>';
            \$html .= '<td>' . \$status . '</td></tr>';
        }
        \$html .= '</table></body></html>';
        
        file_put_contents(\$htmlFile, \$html);
    }
    
    echo \"✅ HTML coverage report generated in: \$htmlDir\\n\";
    echo \"📂 Open: \$htmlDir/\\n\";
} else {
    // Text format
    \$totalLines = 0;
    \$coveredLines = 0;
    
    foreach (\$coverage as \$file => \$lines) {
        echo \"File: \$file\\n\";
        foreach (\$lines as \$line => \$count) {
            \$totalLines++;
            if (\$count > 0) \$coveredLines++;
            \$status = \$count > 0 ? 'COVERED' : 'NOT COVERED';
            echo \"  Line \$line: \$status (\$count)\\n\";
        }
        echo \"\\n\";
    }
    
    \$percentage = \$totalLines > 0 ? (\$coveredLines / \$totalLines) * 100 : 0;
    echo \"📊 Coverage Summary:\\n\";
    echo \"   Total lines: \$totalLines\\n\";
    echo \"   Covered lines: \$coveredLines\\n\";
    echo \"   Coverage: \" . number_format(\$percentage, 2) . \"%\\n\";
}
";

file_put_contents($wrapperScript, $wrapperContent);

// Execute command
if (empty($phpArgs)) {
    echo "📊 Coverage Analysis: $targetFile\n";
} else {
    echo "📊 Coverage Analysis: $targetFile with arguments: " . implode(' ', $phpArgs) . "\n";
}
echo "📁 Output format: $outputFormat\n";

// Build and execute command  
$command = [$phpBinary];
$command = array_merge($command, $xdebugOpts);
$command[] = $wrapperScript;

// Execute with proper output handling
$descriptors = [
    0 => ['pipe', 'r'],  // stdin
    1 => ['pipe', 'w'],  // stdout
    2 => ['pipe', 'w'],  // stderr
];

$process = proc_open($command, $descriptors, $pipes);

if (is_resource($process)) {
    // Close stdin
    fclose($pipes[0]);
    
    // Read and forward stdout
    $stdout = stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    
    // Read and forward stderr
    $stderr = stream_get_contents($pipes[2]);
    fclose($pipes[2]);
    
    // Wait for process to finish and get exit code
    $returnCode = proc_close($process);
    
    // Forward child process output
    if ($stdout !== '') {
        echo $stdout;
    }
    if ($stderr !== '') {
        fwrite(STDERR, $stderr);
    }
    
    // Propagate child process exit code
    if ($returnCode !== 0) {
        exit($returnCode);
    }
}

// Cleanup wrapper script
unlink($wrapperScript);

echo "\n✅ Coverage analysis complete!\n";

if ($outputFormat === 'html') {
    echo "💡 View HTML report:\n";
    echo "   open $coverageDir/html/\n";
} else {
    echo "💡 Coverage data saved to: $coverageDir\n";
}