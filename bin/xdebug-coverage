#!/usr/bin/env php
<?php

declare(strict_types=1);

$projectRoot = require __DIR__ . '/autoload.php';

// Parse options using getopt
$options = getopt('h', ['help', 'json', 'context:']);
$context = $options['context'] ?? null;
$jsonMode = isset($options['json']);

// Show help if requested
if (isset($options['h']) || isset($options['help'])) {
    fwrite(STDOUT, "Usage: xdebug-coverage [--context=TEXT] [--json] -- php script.php [args...]\n");
    fwrite(STDOUT, "\n");
    fwrite(STDOUT, "Executes PHP scripts with Xdebug code coverage and provides coverage analysis.\n");
    fwrite(STDOUT, "\n");
    fwrite(STDOUT, "Options:\n");
    fwrite(STDOUT, "  --context=TEXT   Add contextual description for AI analysis\n");
    fwrite(STDOUT, "  --json          Output results in JSON format\n");
    fwrite(STDOUT, "  -h, --help      Show this help message\n");
    fwrite(STDOUT, "\n");
    fwrite(STDOUT, "Examples:\n");
    fwrite(STDOUT, "  xdebug-coverage -- php test.php\n");
    fwrite(STDOUT, "  xdebug-coverage -- php -f script.php arg1 arg2\n");
    fwrite(STDOUT, "  xdebug-coverage -- php vendor/bin/phpunit TestClass.php\n");
    fwrite(STDOUT, "  xdebug-coverage --context=\"Testing payment processing\" -- php PaymentTest.php\n");
    fwrite(STDOUT, "  xdebug-coverage --json -- php vendor/bin/phpunit\n");
    fwrite(STDOUT, "\n");
    exit(0);
}

// Find the -- separator to get script arguments
$separatorIndex = array_search('--', $argv);
if ($separatorIndex === false || $separatorIndex + 2 >= count($argv)) {
    fwrite(STDERR, "Error: Must use -- separator before php command\n");
    fwrite(STDERR, "Usage: xdebug-coverage [options] -- php <script.php> [args...]\n");
    fwrite(STDERR, "Example: xdebug-coverage -- php test.php\n");
    exit(1);
}

// Extract script and arguments after --
$scriptArgs = array_slice($argv, $separatorIndex + 1);
if (count($scriptArgs) < 2) {
    fwrite(STDERR, "Error: Must specify both 'php' and script file\n");
    fwrite(STDERR, "Usage: xdebug-coverage [options] -- php <script.php> [args...]\n");
    exit(1);
}

$targetFile = $scriptArgs[1];  // Second element after -- (php script.php -> script.php)

// Validate target file exists and is readable
if (!file_exists($targetFile)) {
    fwrite(STDERR, "Error: Target file '$targetFile' does not exist\n");
    exit(1);
}

if (!is_readable($targetFile)) {
    fwrite(STDERR, "Error: Target file '$targetFile' is not readable\n");
    exit(1);
}

$phpArgs = array_slice($scriptArgs, 2); // remaining args after "php script.php"

// Create coverage scripts
// NOTE: Cannot use register_shutdown_function() directly in current process
// because Xdebug functions require Xdebug to be enabled in the target process
$srcPath = $projectRoot . '/src';

$prependScript = tempnam(sys_get_temp_dir(), 'coverage_start_');
$contextValue = $context;
file_put_contents($prependScript, "<?php
xdebug_set_filter(XDEBUG_FILTER_CODE_COVERAGE, XDEBUG_PATH_INCLUDE, ['$srcPath/']);
xdebug_start_code_coverage(XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE);

register_shutdown_function(function() {
    \$coverage = xdebug_get_code_coverage();
    \$result = [];
    
    foreach (\$coverage as \$file => \$lines) {
        \$covered = \$uncovered = [];
        
        foreach (\$lines as \$line => \$status) {
            if (\$status === 1) {
                \$covered[] = \$line;
            } elseif (\$status === -1) {
                \$uncovered[] = \$line;
            }
        }
        
        \$total = count(\$covered) + count(\$uncovered);
        \$result[\$file] = [
            'coverage' => \$total > 0 ? round(count(\$covered) / \$total * 100, 1) : 0,
            'lines_total' => \$total,
            'lines_covered' => count(\$covered),
            'covered_lines' => \$covered,
            'uncovered_lines' => \$uncovered
        ];
    }
    
    // Add context if provided
    \$contextValue = " . var_export($contextValue, true) . ";
    if (\$contextValue !== null) {
        \$result['analysis_context'] = \$contextValue;
    }
    
    echo json_encode(\$result, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
});");

// Execute with Xdebug coverage
$sharedPrependFilter = __DIR__ . '/../src/prepend_filter.php';
$xdebugOptions = [
    '-dzend_extension=xdebug',
    '-dxdebug.mode=coverage',
    "-dauto_prepend_file=$prependScript",
    // Note: coverage has its own specific filter, but we also add the shared filter for trace consistency
];

$cmd = 'php ' . implode(' ', array_map('escapeshellarg', array_merge($xdebugOptions, [$targetFile], $phpArgs)));

// Execute command and capture output with exit code
$outputLines = [];
$exitCode = null;
exec($cmd . ' 2>&1', $outputLines, $exitCode);

// Output results to STDOUT
$output = implode("\n", $outputLines);
fwrite(STDOUT, $output);
if (!empty($output)) {
    fwrite(STDOUT, "\n");
}

unlink($prependScript);

// Show context in output if provided
if ($context !== null) {
    fwrite(STDERR, "\nðŸŽ¯ Context: $context\n");
}

// Always suggest Claude analysis for coverage data  
fwrite(STDERR, "\nðŸ’¡ Analyze with Claude Code:\n");
fwrite(STDERR, "   claude \"Analyze the code coverage data above\"\n");

exit($exitCode);
