#!/usr/bin/env php
<?php

declare(strict_types=1);

// Load autoloader and get project root
$projectRoot = require __DIR__ . '/autoload.php';

function showHelp(string $scriptName): void
{
    echo "Usage: $scriptName [--json] [--claude] -- php script.php [args...]\n";
    echo "\n";
    echo "Profile PHP script execution performance with Xdebug.\n";
    echo "\n";
    echo "Options:\n";
    echo "  --json    JSON output for AI analysis with emoji keys\n";
    echo "  --claude  Auto-analyze with Claude after profiling\n";
    echo "\n";
    echo "Examples:\n";
    echo "  # Human-readable output with units:\n";
    echo "  $scriptName -- php app.php\n";
    echo "\n";
    echo "  # AI-optimized JSON output:\n";
    echo "  $scriptName --json -- php app.php\n";
    echo "\n";
    echo "  # Auto-analyze with Claude:\n";
    echo "  $scriptName --claude -- php app.php\n";
    echo "\n";
    echo "Output:\n";
    echo "  - Default: Human-readable with proper units and KCachegrind suggestions\n";
    echo "  - --json: AI-optimized with emoji keys and comprehensive metrics\n";
    echo "  - Schema: https://koriym.github.io/xdebug-mcp/schemas/xdebug-profile.json\n";
}

// Check for help flag
if (isset($argv[1]) && ($argv[1] === '--help' || $argv[1] === '-h')) {
    showHelp($argv[0]);
    exit(0);
}

// Parse flags
$jsonOutput = in_array('--json', $argv);
$claudeAnalysis = in_array('--claude', $argv);

// Remove flags and find target file
$args = array_values(array_diff($argv, ['--json', '--claude', '--']));
array_shift($args); // remove script name

// Skip 'php' if present
if (isset($args[0]) && $args[0] === 'php') {
    array_shift($args);
}

$targetFile = $args[0] ?? '';
$phpArgs = array_slice($args, 1);

// Check target file exists
if (!file_exists($targetFile)) {
    fwrite(STDERR, "❌ Error: File '$targetFile' not found\n");
    exit(1);
}

// Get Xdebug output directory
$xdebugOutputDir = ini_get('xdebug.output_dir') ?: '/tmp';

echo "📊 Profiling: $targetFile\n";

// Build command with Xdebug profiling enabled
$xdebugOptions = [
    '-dzend_extension=xdebug',
    '-dxdebug.mode=profile',
    '-dxdebug.start_with_request=yes',
    "-dxdebug.output_dir={$xdebugOutputDir}",
    '-dxdebug.use_compression=0',  // Disable compression for easier parsing
];

// Combine all arguments
$allArgs = array_merge($xdebugOptions, [$targetFile], $phpArgs);
$cmd = 'php ' . implode(' ', array_map('escapeshellarg', $allArgs));

// Execute with passthru to show output
$exitCode = 0;
passthru($cmd, $exitCode);

// Generate profile analysis
try {
    $result = generateEnhancedProfileData($xdebugOutputDir, $jsonOutput);

    if ($jsonOutput) {
        // AI-optimized JSON output with emoji keys and units
        echo json_encode($result, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";
        $profileFile = $result['📁 profile_file'];
    } else {
        // Human-readable output with proper units and formatting
        displayHumanReadableProfile($result);
        $profileFile = $result['profile_file'];
    }

    // Auto-analyze with Claude if requested
    if ($claudeAnalysis) {
        echo "\n🤖 Starting Claude Code analysis...\n";

        $localeOutput = shell_exec('defaults read -g AppleLocale') ?: '';
        $lang = str_contains($localeOutput, 'ja_JP') ? 'Japanese' : 'English';
        $claudePrompt = "Analyze this Cachegrind profile file for performance bottlenecks, slow functions, and optimization opportunities. Focus on identifying the highest impact optimization targets and provide specific, actionable recommendations: {$profileFile}. Answer in $lang.";

        passthru('claude ' . escapeshellarg($claudePrompt));
        echo "\n";
        echo "🤖 Claude Code analysis completed. 'claude --continue' if you have follow-up questions.\n";
    }
} catch (Exception $e) {
    fwrite(STDERR, "❌ Error: " . $e->getMessage() . "\n");
    exit(1);
}

function generateEnhancedProfileData(string $xdebugOutputDir, bool $jsonOutput = false): array
{
    // Find the created profile file
    $profileFiles = glob("{$xdebugOutputDir}/cachegrind.out.*");
    if (empty($profileFiles)) {
        throw new \RuntimeException('Profile file not created. Check Xdebug installation.');
    }

    // Get the most recent profile file
    usort($profileFiles, function($a, $b) {
        return filemtime($b) - filemtime($a);
    });
    $profileFile = $profileFiles[0];

    if (!file_exists($profileFile) || !is_readable($profileFile)) {
        throw new \RuntimeException("Profile file not found or not readable: $profileFile");
    }

    $fileSize = filesize($profileFile);
    
    // Comprehensive analysis
    $stats = analyzeCachegrindFile($profileFile);
    
    if ($jsonOutput) {
        // Enhanced result with emoji keys and units for AI
        return [
            // Core file information
            '📁 profile_file' => $profileFile,
            '📊 total_lines' => $stats['total_lines'] . ' lines',
            '💾 file_size_bytes' => $fileSize . ' bytes',
            '📏 file_size_formatted' => $fileSize > 1024 ? round($fileSize / 1024, 1) . 'KB' : $fileSize . 'B',
            
            // Function statistics  
            '📈 functions_count' => $stats['functions_count'] . ' functions',
            '👤 user_functions' => $stats['user_functions'] . ' user',
            '⚙️ internal_functions' => $stats['internal_functions'] . ' internal',
            '📞 total_calls' => $stats['total_calls'] . ' calls',
            
            // Performance metrics
            '⏱️ execution_time_ms' => $stats['execution_time_ms'] . 'ms',
            '🧠 peak_memory_mb' => $stats['peak_memory_mb'] . 'MB',
            
            // I/O and database operations
            '📂 file_io_operations' => $stats['file_io_operations'] . ' operations',
            '🗃️ database_operations' => $stats['database_operations'] . ' queries',
            
            // Analysis metadata
            '🎯 bottleneck_functions' => $stats['bottleneck_functions'],
            '💡 optimization_suggestions' => $stats['optimization_suggestions'],
            
            // Schema and specification
            '📋 specification' => 'https://kcachegrind.github.io/html/CallgrindFormat.html',
            '🔗 schema' => 'https://koriym.github.io/xdebug-mcp/schemas/xdebug-profile.json'
        ];
    } else {
        // Human-readable result without emojis but with all data
        return [
            'profile_file' => $profileFile,
            'total_lines' => $stats['total_lines'],
            'file_size_bytes' => $fileSize,
            'file_size_formatted' => $fileSize > 1024 ? round($fileSize / 1024, 1) . 'KB' : $fileSize . 'B',
            'functions_count' => $stats['functions_count'],
            'user_functions' => $stats['user_functions'],
            'internal_functions' => $stats['internal_functions'],
            'total_calls' => $stats['total_calls'],
            'execution_time_ms' => $stats['execution_time_ms'],
            'peak_memory_mb' => $stats['peak_memory_mb'],
            'file_io_operations' => $stats['file_io_operations'],
            'database_operations' => $stats['database_operations'],
            'bottleneck_functions' => $stats['bottleneck_functions'],
            'optimization_suggestions' => $stats['optimization_suggestions']
        ];
    }
}

function analyzeCachegrindFile(string $profileFile): array
{
    $stats = [
        'total_lines' => 0,
        'functions_count' => 0,
        'user_functions' => 0,
        'internal_functions' => 0,
        'total_calls' => 0,
        'execution_time_ms' => 0,
        'peak_memory_mb' => 0,
        'file_io_operations' => 0,
        'database_operations' => 0,
        'bottleneck_functions' => [],
        'optimization_suggestions' => []
    ];

    $fileIOFunctions = [
        'file_get_contents', 'file_put_contents', 'fopen', 'fread', 'fwrite', 'fclose',
        'glob', 'scandir', 'is_file', 'file_exists', 'is_dir', 'mkdir', 'rmdir',
        'copy', 'rename', 'unlink', 'chmod', 'touch', 'readfile'
    ];

    $dbFunctions = [
        'mysqli_query', 'mysqli_prepare', 'mysqli_execute', 'mysqli_stmt_execute',
        'PDO::query', 'PDO::prepare', 'PDO::exec', 'PDOStatement::execute',
        'mysql_query', 'pg_query', 'sqlite_query'
    ];

    // Simple file-based statistics (Cachegrind format is different from trace format)
    $content = file_get_contents($profileFile);
    $lines = explode("\n", $content);
    
    $stats['total_lines'] = count($lines);
    
    // Count basic Cachegrind elements - accurate counting
    $stats['total_calls'] = substr_count($content, "\ncalls=");
    
    // Use sets to track unique functions
    $uniqueFunctions = [];
    $userFunctions = [];
    $internalFunctions = [];
    
    // Parse functions for classification and analysis
    $functionCosts = [];
    $currentFunction = null;
    
    foreach ($lines as $line) {
        $line = trim($line);
        
        // Function definitions
        if (strpos($line, 'fn=') === 0) {
            $currentFunction = substr($line, 3);
            
            // Skip empty function references (just numbers like "(19)")
            if (preg_match('/^\(\d+\)$/', $currentFunction)) {
                $currentFunction = null; // Don't process costs for unnamed functions
                continue;
            }
            
            // Track unique functions only if they have real names
            if (!isset($uniqueFunctions[$currentFunction])) {
                $uniqueFunctions[$currentFunction] = true;
                
                // Extract actual function name from format like "(2) php::glob" or "(1) fibonacci"
                $functionName = $currentFunction;
                if (preg_match('/\(\d+\)\s+(.+)/', $functionName, $matches)) {
                    $functionName = $matches[1];
                } else {
                    // If it's just a number reference, skip it
                    continue;
                }
                
                // Classify user vs internal functions
                if (strpos($functionName, 'php::') === 0 || strpos($functionName, '{main}') !== false || strpos($functionName, 'require') !== false) {
                    $internalFunctions[$currentFunction] = true;
                } else {
                    $userFunctions[$currentFunction] = true;
                }
                
                // Only check real function names for I/O and DB operations, not require/include
                if (strpos($functionName, 'require') === false && strpos($functionName, 'include') === false) {
                    // Check for I/O and DB operations
                    $cleanFunctionName = $functionName;
                    if (strpos($cleanFunctionName, 'php::') === 0) {
                        $cleanFunctionName = substr($cleanFunctionName, 5); // Remove 'php::' prefix
                    }
                    
                    // Remove function parameters/signatures if present
                    $functionBase = explode('(', $cleanFunctionName)[0];
                    $functionBase = explode('::', $cleanFunctionName)[0];
                    $functionBase = explode('->', $cleanFunctionName)[0];
                    
                    // Be more selective about File I/O (only real file operations)
                    $realFileIOFunctions = ['fopen', 'fread', 'fwrite', 'fclose', 'readfile'];
                    if (in_array($functionBase, $realFileIOFunctions)) {
                        $stats['file_io_operations']++;
                    }
                    
                    // Only count actual database functions (not array operations)
                    if (in_array($functionBase, $dbFunctions)) {
                        $stats['database_operations']++;
                    }
                }
            }
        }
        
        // Cost lines (numeric data) - simplified parsing
        if (preg_match('/^(\d+)/', $line, $matches) && $currentFunction) {
            $cost = (int)$matches[1];
            if (!isset($functionCosts[$currentFunction])) {
                $functionCosts[$currentFunction] = 0;
            }
            $functionCosts[$currentFunction] += $cost;
        }
    }
    
    // Set final counts from unique arrays
    $stats['functions_count'] = count($uniqueFunctions);
    $stats['user_functions'] = count($userFunctions); 
    $stats['internal_functions'] = count($internalFunctions);
    
    // Identify bottlenecks and generate suggestions
    if (!empty($functionCosts)) {
        arsort($functionCosts);
        
        // Filter out meaningless function names and extract readable names
        $meaningfulFunctions = [];
        foreach ($functionCosts as $func => $cost) {
            // Skip number-only references
            if (preg_match('/^\(\d+\)$/', $func)) {
                continue;
            }
            
            // Extract readable function name
            $displayName = $func;
            if (preg_match('/\(\d+\)\s+(.+)/', $func, $matches)) {
                $displayName = $matches[1];
            }
            
            // Skip require/include statements (not optimizable)
            if (strpos($displayName, 'require') !== false || strpos($displayName, 'include') !== false) {
                continue;
            }
            
            $meaningfulFunctions[$displayName] = $cost;
        }
        
        // Top 5 functions with percentages
        $topFunctions = [];
        $totalCost = array_sum($functionCosts);
        if ($totalCost > 0) {
            foreach (array_slice($meaningfulFunctions, 0, 5, true) as $func => $cost) {
                $percentage = round(($cost / $totalCost) * 100, 1);
                $topFunctions[] = "{$func} ({$percentage}%)";
            }
        }
        
        $stats['bottleneck_functions'] = $topFunctions;
        
        // Better estimates based on function costs and file size
        $maxCost = max($functionCosts);
        $totalCost = array_sum($functionCosts);
        
        // Execution time estimate based on total costs (more realistic scaling)
        $stats['execution_time_ms'] = round($totalCost / 50000, 2); // Adjusted for better estimate
        
        // Memory estimate based on function count, call count, and file complexity  
        $baseMemory = 2.5; // Base PHP memory usage in MB
        $functionMemory = $stats['functions_count'] * 0.1; // Memory per function
        $callMemory = $stats['total_calls'] * 0.001; // Memory per call
        $stats['peak_memory_mb'] = round($baseMemory + $functionMemory + $callMemory, 1);
    }
    
    // Estimate call depth (simplified)

    return $stats;
}

function displayHumanReadableProfile(array $result): void
{
    echo "✅ Profile complete: {$result['profile_file']}\n";
    echo "📊 Size: {$result['file_size_formatted']} ({$result['total_lines']} lines)\n";
    echo "📈 Functions: {$result['functions_count']} ({$result['user_functions']} user + {$result['internal_functions']} internal)\n";
    echo "📞 Calls: {$result['total_calls']}\n";
    
    if ($result['execution_time_ms'] > 0) {
        echo "⏱️ Execution: {$result['execution_time_ms']}ms\n";
    }
    
    if ($result['peak_memory_mb'] > 0) {
        echo "🧠 Memory: {$result['peak_memory_mb']}MB peak\n";
    }
    
    // Only show File I/O if there are actual file operations (not just requires)
    if ($result['file_io_operations'] > 0) {
        echo "📂 File I/O: {$result['file_io_operations']} operations\n";
    }
    
    // Only show Database operations if there are actual DB queries
    if ($result['database_operations'] > 0) {
        echo "🗃️ Database: {$result['database_operations']} queries\n";
    }
    
    if (!empty($result['bottleneck_functions'])) {
        echo "🎯 Top functions:\n";
        foreach ($result['bottleneck_functions'] as $func) {
            echo "   $func\n";
        }
    }
    
    echo "\n💡 claude \"Analyze {$result['profile_file']}\"\n";
    echo "💡 kcachegrind {$result['profile_file']}\n";
}

exit($exitCode);
