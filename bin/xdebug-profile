#!/usr/bin/env php
<?php

declare(strict_types=1);

// Load autoloader and get project root
$projectRoot = require __DIR__ . '/autoload.php';

// Load common argument parser
$parse = require __DIR__ . '/parse.php';

// Parse command line arguments
function showHelp(string $scriptName): void {
    echo "Usage: $scriptName PHP_FILE [-- PHP_ARGS...]\n";
    echo "       $scriptName -- PHP_BINARY SCRIPT_FILE [SCRIPT_ARGS...]\n";
    echo "\n";
    echo "Runs Xdebug profiling on the specified PHP file or command.\n";
    echo "\n";
    echo "Arguments:\n";
    echo "  PHP_FILE      Path to PHP file to profile (required)\n";
    echo "  PHP_ARGS      Arguments to pass to the PHP script (after --)\n";
    echo "  PHP_BINARY    Custom PHP binary path (when using -- prefix)\n";
    echo "  SCRIPT_FILE   PHP script to profile (when using -- prefix)\n";
    echo "  SCRIPT_ARGS   Arguments for the script (when using -- prefix)\n";
    echo "\n";
    echo "Examples:\n";
    echo "  # Standard usage:\n";
    echo "  $scriptName test/debug_test.php                    # Profile test file\n";
    echo "  $scriptName bin/page.php -- get /                 # Profile with arguments\n";
    echo "\n";
    echo "  # Custom PHP binary:\n";
    echo "  $scriptName -- php bin/page.php get /             # Natural PHP command style\n";
    echo "  $scriptName -- /usr/bin/php8.3 script.php args   # Specific PHP version\n";
    echo "\n";
}

// Find -- separator to limit help flag checking
$separatorIndex = array_search('--', $argv);
$argsToCheck = $separatorIndex !== false 
    ? array_slice($argv, 0, $separatorIndex)  // Args before --
    : $argv;                                   // All args if no --

// Check for help flag or missing argument (only in pre-separator args)
if (in_array('--help', $argsToCheck) || in_array('-h', $argsToCheck) || count($argv) < 2) {
    showHelp($argv[0]);
    if (count($argv) < 2) {
        fwrite(STDERR, "❌ Error: PHP file argument is required\n");
        exit(1);
    }
    exit(0);
}

// Parse arguments using common function
[$phpBinary, $targetFile, $phpArgs] = $parse($argv);

// Check target file exists
if (!file_exists($targetFile)) {
    fwrite(STDERR, "❌ Error: File '$targetFile' not found\n");
    fwrite(STDERR, "Use '{$argv[0]} --help' for usage information\n");
    exit(1);
}

// Generate unique profile filename
$profileTimestamp = date('Ymd_His');

// Build Xdebug options (Xdebug 3.x format)
$xdebugOpts = [
    '-dzend_extension=xdebug',
    '-dxdebug.mode=profile',
    '-dxdebug.start_with_request=yes',
    '-dxdebug.output_dir=/tmp',
    '-dxdebug.profiler_output_name=cachegrind.out.%t',
    '-dxdebug.use_compression=0'
];

// Build command
$command = [$phpBinary];
$command = array_merge($command, $xdebugOpts);
$command[] = $targetFile;
$command = array_merge($command, $phpArgs);

// Execute command
if (empty($phpArgs)) {
    echo "📊 Profiling: $targetFile\n";
} else {
    echo "📊 Profiling: $targetFile with arguments: " . implode(' ', $phpArgs) . "\n";
}

// Execute with proper output handling
$descriptors = [
    0 => ['pipe', 'r'],  // stdin
    1 => ['pipe', 'w'],  // stdout
    2 => ['pipe', 'w'],  // stderr
];

$process = proc_open($command, $descriptors, $pipes);

if (is_resource($process)) {
    // Close stdin
    fclose($pipes[0]);
    
    // Read and forward stdout
    $stdout = stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    
    // Read and forward stderr
    $stderr = stream_get_contents($pipes[2]);
    fclose($pipes[2]);
    
    // Wait for process to finish and get exit code
    $returnCode = proc_close($process);
    
    // Forward child process output
    if ($stdout !== '') {
        echo $stdout;
    }
    if ($stderr !== '') {
        fwrite(STDERR, $stderr);
    }
    
    // Propagate child process exit code
    if ($returnCode !== 0) {
        exit($returnCode);
    }
}

// Find the generated profile file (Cachegrind format)
$profileFiles = glob('/tmp/cachegrind.out.*');

if (!empty($profileFiles)) {
    // Sort by modification time (newest first)
    usort($profileFiles, function($a, $b) {
        return filemtime($b) - filemtime($a);
    });
    
    $latestProfile = $profileFiles[0];
    $fileSize = formatBytes(filesize($latestProfile));
    
    echo "✅ Profile complete: $latestProfile\n";
    echo "📊 Size: $fileSize\n";
    
    // Display basic profile info if available
    $content = file_get_contents($latestProfile);
    $functionCount = substr_count($content, "\nfn=");
    $callCount = substr_count($content, "\ncalls=");
    
    echo "📈 Functions: $functionCount\n";
    echo "📞 Calls: $callCount\n";
    echo "\n";
    echo "💡 Analyze with KCachegrind:\n";
    echo "   kcachegrind $latestProfile\n";
    echo "\n";
    echo "💡 Or use qcachegrind on macOS:\n";
    echo "   qcachegrind $latestProfile\n";
} else {
    echo "❌ No profile file generated. Check Xdebug configuration.\n";
    echo "💡 Ensure Xdebug is installed and profiling is enabled:\n";
    echo "   php -m | grep xdebug\n";
    exit(1);
}

function formatBytes(int $bytes, int $precision = 1): string {
    $units = ['B', 'K', 'M', 'G'];
    
    for ($i = 0; $bytes > 1024 && $i < count($units) - 1; $i++) {
        $bytes /= 1024;
    }
    
    return round($bytes, $precision) . $units[$i];
}