#!/usr/bin/env php
<?php
/**
 * AMPHP-based Persistent Debug Server
 * å˜ä¸€ãƒ—ãƒ­ã‚»ã‚¹ã§XdebugæŽ¥ç¶šï¼ˆ9004ï¼‰ã¨åˆ¶å¾¡ã‚µãƒ¼ãƒãƒ¼ï¼ˆ9005ï¼‰ã‚’ç®¡ç†
 * ãƒ—ãƒ­ã‚»ã‚¹åˆ†é›¢ã®å•é¡Œã‚’è§£æ±ºã—ã€åŒä¸€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã§Xdebugã‚½ã‚±ãƒƒãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Koriym\XdebugMcp\XdebugClient;
use Amp\Socket\ResourceSocket;
use Amp\Socket\ResourceServerSocket;
use Amp\Socket\SocketException;
use function Amp\Socket\listen;

class AmpPersistentDebugServer
{
    private ?ResourceSocket $xdebugSocket = null;
    private XdebugClient $xdebugClient;
    private array $sessionInfo = [];
    private string $host = '127.0.0.1';
    private int $debugPort = 9004;
    private int $controlPort = 9005;
    private bool $running = true;
    private int $transactionId = 1;

    public function __construct()
    {
        $this->xdebugClient = new XdebugClient($this->host, $this->debugPort);
        echo "ðŸš€ AMP Persistent Debug Server starting...\n";
        echo "Xdebug port: {$this->debugPort}\n";
        echo "Control port: {$this->controlPort}\n";
    }

    public function start(): void
    {
        // Xdebug connection server (port 9004)
        $xdebugServer = listen("{$this->host}:{$this->debugPort}");
        echo "ðŸ“¡ Waiting for Xdebug connection on {$this->host}:{$this->debugPort}...\n";

        // Control command server (port 9005) 
        $controlServer = listen("{$this->host}:{$this->controlPort}");
        echo "ðŸŽ›ï¸  Control server ready on {$this->host}:{$this->controlPort}...\n";

        // Handle both servers concurrently
        \Amp\async(fn() => $this->handleXdebugConnections($xdebugServer));
        \Amp\async(fn() => $this->handleControlConnections($controlServer));

        // Maintain main loop
        while ($this->running) {
            \Amp\delay(0.1);
        }
    }

    private function handleXdebugConnections(ResourceServerSocket $server): void
    {
        try {
            while (true) {
                $socket = $server->accept();
                echo "âœ… Xdebug connected!\n";
                $this->xdebugSocket = $socket;
                
                \Amp\async(fn() => $this->handleXdebugSession($socket));
            }
        } catch (SocketException $e) {
            echo "âŒ Xdebug server error: " . $e->getMessage() . "\n";
        }
    }

    private function handleControlConnections(ResourceServerSocket $server): void
    {
        try {
            while (true) {
                $socket = $server->accept();
                \Amp\async(fn() => $this->handleControlClient($socket));
            }
        } catch (SocketException $e) {
            echo "âŒ Control server error: " . $e->getMessage() . "\n";
        }
    }

    private function handleXdebugSession(ResourceSocket $socket): void
    {
        try {
            // Read initialization data
            $data = $socket->read();
            if ($data) {
                echo "ðŸ“¨ Received: " . trim($data) . "\n";
                $this->sessionInfo = $this->parseSessionInfo($data);
                $this->saveSessionState();
            }

            echo "ðŸ”§ Session ready for debugging commands\n";

            // Keep session alive - let each command handler perform individual socket reads
            echo "â³ Waiting for MCP commands (session active)\n";
            while ($this->xdebugSocket && $this->running) {
                \Amp\delay(1.0);
            }
        } catch (\Exception $e) {
            echo "âŒ Xdebug session error: " . $e->getMessage() . "\n";
        } finally {
            if ($this->xdebugSocket === $socket) {
                $this->xdebugSocket = null;
                echo "ðŸ”Œ Xdebug session ended\n";
            }
            $socket->close();
        }
    }

    private function handleControlClient(ResourceSocket $socket): void
    {
        try {
            $command = trim($socket->read() ?? '');
            if ($command) {
                $response = $this->handleControlCommand($command);
                $socket->write($response);
            }
        } catch (\Exception $e) {
            echo "âŒ Control client error: " . $e->getMessage() . "\n";
        } finally {
            $socket->close();
        }
    }

    private function handleControlCommand(string $command): string
    {
        echo "ðŸŽ® Control command: $command\n";
        
        $parts = explode(' ', $command, 2);
        $cmd = $parts[0];
        $args = $parts[1] ?? '';

        switch ($cmd) {
            case 'breakpoint':
                return $this->setBreakpoint($args);
            case 'continue':
                return $this->continueExecution();
            case 'step':
                return $this->stepInto();
            case 'step_over':
                return $this->stepOver();
            case 'step_out':
                return $this->stepOut();
            case 'status':
                return $this->getStatus();
            case 'variables':
                return $this->getVariables();
            case 'reset':
                return $this->resetSession();
            case 'disconnect':
                return $this->forceDisconnect();
            case 'shutdown':
                return $this->shutdownServer();
            default:
                return "Unknown command: $cmd\nAvailable: breakpoint, continue, step, step_over, step_out, status, variables, reset, disconnect, shutdown\n";
        }
    }

    private function setBreakpoint(string $args): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        // Stricter argument validation - must contain exactly one colon
        $colonCount = substr_count($args, ':');
        if ($colonCount !== 1) {
            return "ERROR: Invalid format. Expected 'filename:line', got $colonCount colons\n";
        }

        // Parse: filename:line
        [$filename, $line] = explode(':', $args, 2);
        
        // Validate filename after trimming
        $filename = trim($filename);
        if (empty($filename)) {
            return "ERROR: Filename cannot be empty\n";
        }
        
        // Validate line number - must be positive integer
        $line = trim($line);
        if (!ctype_digit($line) || (int)$line <= 0) {
            return "ERROR: Line number must be a positive integer, got '$line'\n";
        }
        $lineNumber = (int)$line;
        
        // Handle relative paths via realpath fallback
        $realPath = realpath($filename);
        if ($realPath === false) {
            // Try with current directory for relative paths
            $realPath = realpath(getcwd() . DIRECTORY_SEPARATOR . $filename);
        }
        
        if ($realPath === false) {
            return "ERROR: File '$filename' not found\n";
        }
        
        // Always construct file URI with three slashes and percent-encoded path segments
        $pathParts = explode(DIRECTORY_SEPARATOR, $realPath);
        $encodedParts = array_map('rawurlencode', $pathParts);
        $encodedPath = implode('/', $encodedParts);
        
        // Consistent file URI format for both Windows and POSIX
        $fileUri = 'file:///' . $encodedPath;
        
        // Generate unique DBGp transaction ID
        $transactionId = $this->transactionId++;
        
        $command = "breakpoint_set -i $transactionId -t line -f $fileUri -n $lineNumber\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Breakpoint response: $response\n";
        } catch (\Exception $e) {
            return "Breakpoint error: " . $e->getMessage() . "\n";
        }
    }

    private function continueExecution(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "run -i " . $this->transactionId++ . "\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Continue response: $response\n";
        } catch (\Exception $e) {
            return "Continue error: " . $e->getMessage() . "\n";
        }
    }

    private function stepInto(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_into -i " . $this->transactionId++ . "\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step response: $response\n";
        } catch (\Exception $e) {
            return "Step error: " . $e->getMessage() . "\n";
        }
    }

    private function getStatus(): string
    {
        $status = [
            'xdebug_connected' => $this->xdebugSocket !== null,
            'session_info' => $this->sessionInfo,
            'server_running' => $this->running
        ];
        
        return json_encode($status, JSON_PRETTY_PRINT) . "\n";
    }

    private function getVariables(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "context_get -i " . $this->transactionId++ . "\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Variables response: $response\n";
        } catch (\Exception $e) {
            return "Variables error: " . $e->getMessage() . "\n";
        }
    }

    private function stepOver(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_over -i " . $this->transactionId++ . "\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step Over response: $response\n";
        } catch (\Exception $e) {
            return "Step Over error: " . $e->getMessage() . "\n";
        }
    }

    private function stepOut(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_out -i " . $this->transactionId++ . "\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step Out response: $response\n";
        } catch (\Exception $e) {
            return "Step Out error: " . $e->getMessage() . "\n";
        }
    }

    private function resetSession(): string
    {
        echo "ðŸ”„ Resetting debug session...\n";
        
        // Disconnect current Xdebug connection
        if ($this->xdebugSocket) {
            try {
                $this->xdebugSocket->write("detach -i " . $this->transactionId++ . "\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Detach error: " . $e->getMessage() . "\n";
            }
            $this->xdebugSocket = null;
        }
        
        // Clear session information
        $this->sessionInfo = [];
        
        // Clear temporary files
        $tempFiles = [
            '/tmp/amp_persistent_debug_session.json',
            '/tmp/xdebug_session_global.json'
        ];
        
        foreach ($tempFiles as $file) {
            if (file_exists($file)) {
                unlink($file);
            }
        }
        
        echo "âœ… Session reset completed\n";
        return "OK: Session reset completed. Ready for new debug connection.\n";
    }

    private function forceDisconnect(): string
    {
        echo "ðŸ’¥ Force disconnecting Xdebug session...\n";
        
        if ($this->xdebugSocket) {
            try {
                // Stop script execution with DBGp stop command
                $this->xdebugSocket->write("stop -i " . $this->transactionId++ . "\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Stop error: " . $e->getMessage() . "\n";
            }
            $this->xdebugSocket = null;
        }
        
        $this->sessionInfo = [];
        
        return "OK: Xdebug session forcefully disconnected.\n";
    }

    private function shutdownServer(): string
    {
        echo "ðŸ›‘ Shutting down server...\n";
        
        // Properly cleanup current connection
        if ($this->xdebugSocket) {
            try {
                $this->xdebugSocket->write("detach -i " . $this->transactionId++ . "\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Cleanup error: " . $e->getMessage() . "\n";
            }
        }
        
        $this->running = false;
        
        return "OK: Server shutdown initiated.\n";
    }

    private function parseSessionInfo(string $data): array
    {
        if (preg_match('/<init[^>]*fileuri="([^"]*)"[^>]*>/', $data, $matches)) {
            return ['fileuri' => $matches[1], 'raw' => $data];
        }
        return ['raw' => $data];
    }

    private function saveSessionState(): void
    {
        $state = [
            'connected' => true,
            'host' => $this->host,
            'debug_port' => $this->debugPort,
            'control_port' => $this->controlPort,
            'session_info' => $this->sessionInfo,
            'timestamp' => time()
        ];
        
        file_put_contents('/tmp/amp_persistent_debug_session.json', json_encode($state, JSON_PRETTY_PRINT));
        echo "ðŸ’¾ Session state saved\n";
    }
}

// Signal handling
pcntl_async_signals(true);
pcntl_signal(SIGINT, function () {
    echo "\nðŸ›‘ Shutting down server...\n";
    exit(0);
});

$server = new AmpPersistentDebugServer();
$server->start();