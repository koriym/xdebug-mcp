#!/usr/bin/env php
<?php
/**
 * AMPHP-based Persistent Debug Server
 * å˜ä¸€ãƒ—ãƒ­ã‚»ã‚¹ã§XdebugæŽ¥ç¶šï¼ˆ9004ï¼‰ã¨åˆ¶å¾¡ã‚µãƒ¼ãƒãƒ¼ï¼ˆ9005ï¼‰ã‚’ç®¡ç†
 * ãƒ—ãƒ­ã‚»ã‚¹åˆ†é›¢ã®å•é¡Œã‚’è§£æ±ºã—ã€åŒä¸€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å†…ã§Xdebugã‚½ã‚±ãƒƒãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Koriym\XdebugMcp\XdebugClient;
use Amp\Socket\ResourceSocket;
use Amp\Socket\ResourceServerSocket;
use Amp\Socket\SocketException;
use function Amp\Socket\listen;

class AmpPersistentDebugServer
{
    private ?ResourceSocket $xdebugSocket = null;
    private XdebugClient $xdebugClient;
    private array $sessionInfo = [];
    private string $host = '127.0.0.1';
    private int $debugPort = 9004;
    private int $controlPort = 9005;
    private bool $running = true;

    public function __construct()
    {
        $this->xdebugClient = new XdebugClient($this->host, $this->debugPort);
        echo "ðŸš€ AMP Persistent Debug Server starting...\n";
        echo "Xdebug port: {$this->debugPort}\n";
        echo "Control port: {$this->controlPort}\n";
    }

    public function start(): void
    {
        // XdebugæŽ¥ç¶šã‚µãƒ¼ãƒãƒ¼ (9004ãƒãƒ¼ãƒˆ)
        $xdebugServer = listen("{$this->host}:{$this->debugPort}");
        echo "ðŸ“¡ Waiting for Xdebug connection on {$this->host}:{$this->debugPort}...\n";

        // åˆ¶å¾¡ã‚³ãƒžãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ (9005ãƒãƒ¼ãƒˆ) 
        $controlServer = listen("{$this->host}:{$this->controlPort}");
        echo "ðŸŽ›ï¸  Control server ready on {$this->host}:{$this->controlPort}...\n";

        // ä¸¡æ–¹ã®ã‚µãƒ¼ãƒãƒ¼ã‚’ä¸¦è¡Œå‡¦ç†
        \Amp\async(fn() => $this->handleXdebugConnections($xdebugServer));
        \Amp\async(fn() => $this->handleControlConnections($controlServer));

        // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’ç¶­æŒ
        while ($this->running) {
            \Amp\delay(0.1);
        }
    }

    private function handleXdebugConnections(ResourceServerSocket $server): void
    {
        try {
            while (true) {
                $socket = $server->accept();
                echo "âœ… Xdebug connected!\n";
                $this->xdebugSocket = $socket;
                
                \Amp\async(fn() => $this->handleXdebugSession($socket));
            }
        } catch (SocketException $e) {
            echo "âŒ Xdebug server error: " . $e->getMessage() . "\n";
        }
    }

    private function handleControlConnections(ResourceServerSocket $server): void
    {
        try {
            while (true) {
                $socket = $server->accept();
                \Amp\async(fn() => $this->handleControlClient($socket));
            }
        } catch (SocketException $e) {
            echo "âŒ Control server error: " . $e->getMessage() . "\n";
        }
    }

    private function handleXdebugSession(ResourceSocket $socket): void
    {
        try {
            // åˆæœŸåŒ–ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
            $data = $socket->read();
            if ($data) {
                echo "ðŸ“¨ Received: " . trim($data) . "\n";
                $this->sessionInfo = $this->parseSessionInfo($data);
                $this->saveSessionState();
            }

            echo "ðŸ”§ Session ready for debugging commands\n";

            // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¶­æŒï¼ˆã‚³ãƒžãƒ³ãƒ‰ã‚’å¾…æ©Ÿï¼‰
            while ($this->xdebugSocket && $this->running) {
                try {
                    $data = $socket->read();
                    if ($data === null) {
                        echo "âŒ Xdebug connection closed\n";
                        break;
                    }
                    
                    if ($data !== '') {
                        echo "ðŸ“¨ Xdebug data: " . trim($data) . "\n";
                        
                        if (strpos($data, 'status="stopping"') !== false) {
                            echo "âœ… Script execution completed\n";
                            break;
                        }
                    }
                    
                    \Amp\delay(0.1);
                } catch (\Exception $e) {
                    echo "âŒ Xdebug read error: " . $e->getMessage() . "\n";
                    break;
                }
            }
        } catch (\Exception $e) {
            echo "âŒ Xdebug session error: " . $e->getMessage() . "\n";
        } finally {
            if ($this->xdebugSocket === $socket) {
                $this->xdebugSocket = null;
                echo "ðŸ”Œ Xdebug session ended\n";
            }
            $socket->close();
        }
    }

    private function handleControlClient(ResourceSocket $socket): void
    {
        try {
            $command = trim($socket->read() ?? '');
            if ($command) {
                $response = $this->handleControlCommand($command);
                $socket->write($response);
            }
        } catch (\Exception $e) {
            echo "âŒ Control client error: " . $e->getMessage() . "\n";
        } finally {
            $socket->close();
        }
    }

    private function handleControlCommand(string $command): string
    {
        echo "ðŸŽ® Control command: $command\n";
        
        $parts = explode(' ', $command, 2);
        $cmd = $parts[0];
        $args = $parts[1] ?? '';

        switch ($cmd) {
            case 'breakpoint':
                return $this->setBreakpoint($args);
            case 'continue':
                return $this->continueExecution();
            case 'step':
                return $this->stepInto();
            case 'step_over':
                return $this->stepOver();
            case 'step_out':
                return $this->stepOut();
            case 'status':
                return $this->getStatus();
            case 'variables':
                return $this->getVariables();
            case 'reset':
                return $this->resetSession();
            case 'disconnect':
                return $this->forceDisconnect();
            case 'shutdown':
                return $this->shutdownServer();
            default:
                return "Unknown command: $cmd\nAvailable: breakpoint, continue, step, step_over, step_out, status, variables, reset, disconnect, shutdown\n";
        }
    }

    private function setBreakpoint(string $args): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        // Parse: filename:line
        [$filename, $line] = explode(':', $args, 2);
        
        // Validate and normalize filename
        if (empty($filename)) {
            return "ERROR: Filename cannot be empty\n";
        }
        
        // Canonicalize path
        $realPath = realpath($filename);
        if ($realPath === false) {
            // If realpath fails, try with current directory
            $realPath = realpath(getcwd() . DIRECTORY_SEPARATOR . $filename);
        }
        
        if ($realPath === false) {
            return "ERROR: File '$filename' not found\n";
        }
        
        // Build proper file:// URI with percent-encoded path components
        $pathParts = explode(DIRECTORY_SEPARATOR, $realPath);
        $encodedParts = array_map('rawurlencode', $pathParts);
        $encodedPath = implode('/', $encodedParts);
        
        // Construct file URI (Windows needs file:///C:/ format)
        if (PHP_OS_FAMILY === 'Windows') {
            $fileUri = 'file:///' . $encodedPath;
        } else {
            $fileUri = 'file://' . $encodedPath;
        }
        
        $command = "breakpoint_set -i 1 -t line -f $fileUri -n $line\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Breakpoint response: $response\n";
        } catch (\Exception $e) {
            return "Breakpoint error: " . $e->getMessage() . "\n";
        }
    }

    private function continueExecution(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "run -i 2\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Continue response: $response\n";
        } catch (\Exception $e) {
            return "Continue error: " . $e->getMessage() . "\n";
        }
    }

    private function stepInto(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_into -i 3\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step response: $response\n";
        } catch (\Exception $e) {
            return "Step error: " . $e->getMessage() . "\n";
        }
    }

    private function getStatus(): string
    {
        $status = [
            'xdebug_connected' => $this->xdebugSocket !== null,
            'session_info' => $this->sessionInfo,
            'server_running' => $this->running
        ];
        
        return json_encode($status, JSON_PRETTY_PRINT) . "\n";
    }

    private function getVariables(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "context_get -i 4\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Variables response: $response\n";
        } catch (\Exception $e) {
            return "Variables error: " . $e->getMessage() . "\n";
        }
    }

    private function stepOver(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_over -i 5\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step Over response: $response\n";
        } catch (\Exception $e) {
            return "Step Over error: " . $e->getMessage() . "\n";
        }
    }

    private function stepOut(): string
    {
        if (!$this->xdebugSocket) {
            return "ERROR: No active Xdebug session\n";
        }

        $command = "step_out -i 6\0";
        $this->xdebugSocket->write($command);
        
        try {
            $response = $this->xdebugSocket->read();
            return "Step Out response: $response\n";
        } catch (\Exception $e) {
            return "Step Out error: " . $e->getMessage() . "\n";
        }
    }

    private function resetSession(): string
    {
        echo "ðŸ”„ Resetting debug session...\n";
        
        // ç¾åœ¨ã®XdebugæŽ¥ç¶šã‚’åˆ‡æ–­
        if ($this->xdebugSocket) {
            try {
                $this->xdebugSocket->write("detach -i 99\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Detach error: " . $e->getMessage() . "\n";
            }
            $this->xdebugSocket = null;
        }
        
        // ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
        $this->sessionInfo = [];
        
        // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢
        $tempFiles = [
            '/tmp/amp_persistent_debug_session.json',
            '/tmp/xdebug_session_global.json'
        ];
        
        foreach ($tempFiles as $file) {
            if (file_exists($file)) {
                unlink($file);
            }
        }
        
        echo "âœ… Session reset completed\n";
        return "OK: Session reset completed. Ready for new debug connection.\n";
    }

    private function forceDisconnect(): string
    {
        echo "ðŸ’¥ Force disconnecting Xdebug session...\n";
        
        if ($this->xdebugSocket) {
            try {
                // DBGpã®stopã‚³ãƒžãƒ³ãƒ‰ã§ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œã‚‚åœæ­¢
                $this->xdebugSocket->write("stop -i 98\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Stop error: " . $e->getMessage() . "\n";
            }
            $this->xdebugSocket = null;
        }
        
        $this->sessionInfo = [];
        
        return "OK: Xdebug session forcefully disconnected.\n";
    }

    private function shutdownServer(): string
    {
        echo "ðŸ›‘ Shutting down server...\n";
        
        // ç¾åœ¨ã®æŽ¥ç¶šã‚’é©åˆ‡ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if ($this->xdebugSocket) {
            try {
                $this->xdebugSocket->write("detach -i 97\0");
                $this->xdebugSocket->close();
            } catch (\Exception $e) {
                echo "âš ï¸  Cleanup error: " . $e->getMessage() . "\n";
            }
        }
        
        $this->running = false;
        
        return "OK: Server shutdown initiated.\n";
    }

    private function parseSessionInfo(string $data): array
    {
        if (preg_match('/<init[^>]*fileuri="([^"]*)"[^>]*>/', $data, $matches)) {
            return ['fileuri' => $matches[1], 'raw' => $data];
        }
        return ['raw' => $data];
    }

    private function saveSessionState(): void
    {
        $state = [
            'connected' => true,
            'host' => $this->host,
            'debug_port' => $this->debugPort,
            'control_port' => $this->controlPort,
            'session_info' => $this->sessionInfo,
            'timestamp' => time()
        ];
        
        file_put_contents('/tmp/amp_persistent_debug_session.json', json_encode($state, JSON_PRETTY_PRINT));
        echo "ðŸ’¾ Session state saved\n";
    }
}

// ã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
pcntl_async_signals(true);
pcntl_signal(SIGINT, function () {
    echo "\nðŸ›‘ Shutting down server...\n";
    exit(0);
});

$server = new AmpPersistentDebugServer();
$server->start();