#!/usr/bin/env php
<?php
/**
 * Xdebug Debug Session Starter
 * Starts a PHP script with Xdebug debugging enabled and waits for debugger connection
 */

// Load common argument parser
$parse = require __DIR__ . '/parse.php';

function showHelp(string $scriptName): void {
    echo "Usage: $scriptName [OPTIONS] PHP_FILE [-- PHP_ARGS...]\n";
    echo "       $scriptName [OPTIONS] -- PHP_BINARY SCRIPT_FILE [SCRIPT_ARGS...]\n";
    echo "\n";
    echo "Starts a PHP script with Xdebug debugging enabled.\n";
    echo "\n";
    echo "Options:\n";
    echo "  --clean       Clean up existing debug sessions before starting\n";
    echo "  --help, -h    Show this help message\n";
    echo "\n";
    echo "Arguments:\n";
    echo "  PHP_FILE      Path to PHP file to debug (required)\n";
    echo "  PHP_ARGS      Arguments to pass to the PHP script (after --)\n";
    echo "  PHP_BINARY    Custom PHP binary path (when using -- prefix)\n";
    echo "  SCRIPT_FILE   PHP script to debug (when using -- prefix)\n";
    echo "  SCRIPT_ARGS   Arguments for the script (when using -- prefix)\n";
    echo "\n";
    echo "Examples:\n";
    echo "  $scriptName test-scripts/buggy_calculation_code.php\n";
    echo "  $scriptName script.php -- arg1 arg2\n";
    echo "  $scriptName -- php script.php arg1 arg2\n";
    echo "  $scriptName --clean script.php\n";
}

// Parse options first
$doClean = false;
$cleanedArgv = [];
foreach ($argv as $arg) {
    if ($arg === '--clean') {
        $doClean = true;
    } else {
        $cleanedArgv[] = $arg;
    }
}

// Find -- separator to limit help flag checking
$separatorIndex = array_search('--', $cleanedArgv);
$argsToCheck = $separatorIndex !== false
    ? array_slice($cleanedArgv, 0, $separatorIndex)
    : $cleanedArgv;

// Check for help flag or missing argument
if (in_array('--help', $argsToCheck) || in_array('-h', $argsToCheck) || count($cleanedArgv) < 2) {
    showHelp($cleanedArgv[0]);
    if (count($cleanedArgv) < 2) {
        fwrite(STDERR, "‚ùå Error: PHP file argument is required\n");
        exit(1);
    }
    exit(0);
}

// Parse arguments using common function
[$phpBinary, $targetFile, $phpArgs] = $parse($cleanedArgv);

// Validate target file exists
if (!file_exists($targetFile)) {
    fwrite(STDERR, "‚ùå Error: File '$targetFile' not found\n");
    fwrite(STDERR, "Use '{$cleanedArgv[0]} --help' for usage information\n");
    exit(1);
}

// Validate PHP binary
if (!is_executable($phpBinary)) {
    fwrite(STDERR, "‚ùå Error: PHP binary '$phpBinary' not found or not executable\n");
    exit(1);
}

echo "üêõ Starting Xdebug debugging session...\n";
echo "üìÅ Target script: $targetFile\n";
if (!empty($phpArgs)) {
    echo "üìã Script arguments: " . implode(' ', $phpArgs) . "\n";
}
echo "üîå Xdebug will listen on 127.0.0.1:9004\n";
echo "üéØ MCP tools can connect to debug this session\n\n";

// Clean up existing sessions if requested
if ($doClean) {
    echo "üßπ Cleaning up existing debug sessions for: " . basename($targetFile) . "\n";

    $scriptBasename = basename($targetFile);
    $checkCmd = "pgrep -f " . escapeshellarg("xdebug.*mode=debug.*$scriptBasename") . " > /dev/null 2>&1";

    exec($checkCmd, $output, $returnCode);

    if ($returnCode === 0) { // pgrep found matching processes
        $killCmd = "pkill -f " . escapeshellarg("xdebug.*mode=debug.*$scriptBasename") . " 2>/dev/null";
        exec($killCmd);
        usleep(500000); // Wait 0.5s for cleanup
        echo "‚úÖ Cleaned up existing sessions\n";
    } else {
        echo "‚ÑπÔ∏è  No existing debug sessions found\n";
    }
}

// Build command with arguments
$command = [$phpBinary];
$command[] = '-dzend_extension=xdebug';
$command[] = '-dxdebug.mode=debug';
$command[] = '-dxdebug.client_host=127.0.0.1';
$command[] = '-dxdebug.client_port=9004';
$command[] = '-dxdebug.start_with_request=yes';
$command[] = $targetFile;
$command = array_merge($command, $phpArgs);

// Set environment variable
putenv('XDEBUG_SESSION=1');

echo "üîÑ Starting script - will BREAK AT FIRST LINE\n";
if (!empty($phpArgs)) {
    echo "üöÄ Running: " . basename($targetFile) . " with arguments: " . implode(' ', $phpArgs) . "\n";
} else {
    echo "üöÄ Running: " . basename($targetFile) . "\n";
}
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n";

echo "Starting PHP script with Xdebug (will pause at first line)...\n";
echo "Use Ctrl+C to stop if needed.\n\n";

// Execute with proper output handling using proc_open
$descriptors = [
    0 => ['pipe', 'r'],  // stdin
    1 => ['pipe', 'w'],  // stdout
    2 => ['pipe', 'w'],  // stderr
];

$process = proc_open($command, $descriptors, $pipes);

if (!is_resource($process)) {
    fwrite(STDERR, "‚ùå Error: Failed to start PHP process\n");
    exit(1);
}

// Close stdin since we don't need it
fclose($pipes[0]);

// Read and forward stdout
$stdout = stream_get_contents($pipes[1]);
fclose($pipes[1]);

// Read and forward stderr
$stderr = stream_get_contents($pipes[2]);
fclose($pipes[2]);

// Wait for process to finish and get exit code
$returnCode = proc_close($process);

// Forward child process output
if ($stdout !== '') {
    echo $stdout;
}
if ($stderr !== '') {
    fwrite(STDERR, $stderr);
}

// Propagate child process exit code
exit($returnCode);
